So far we've implemented *split* and *apply* operations; now it's time to explore *combine* operations in **targets** pipelines.

In this issue you'll add two *combiners* to serve different purposes - the first will combine all of the annual observation tallies into one giant table, and the second will summarize the set of state-specific timeseries plots generated by the task table. 

### Background

#### Approach

Given your current level of knowledge, if you were asked to add a target combining the tally outputs you would likely add a call to `tar_target` and use the branches as input to a `command` that aggregated the data. While this would certainly work, the number of inputs to a combiner should change if the number of tasks changes. If we hand-coded a combiner target with `tar_target` that accepted a set of inputs (e.g., `command: combine_tallies(tally_WI, tally_MI, [etc])`), we'd need to manually edit the inputs to that function anytime we changed the `states` vector. That would be a pain and would make our pipeline susceptible to human error if we forgot or made a mistake in that editing. 

#### Implementation

The **targets** way to use combiners for static branching is to work with the `tar_combine()` function (recall that **combiners** are automatically applied to the output in dynamic branching). `tar_combine()` is set up in a similar way to `tar_target()`, where you supply the target name and a function to use to create the target as the `command`. The difference is that the input to the `command` will be multiple targets passed in to the `...` argument. The output from a `tar_combine()` can be an R object or a file, but file targets need to have `format = "file"` passed in to `tar_combine()` and the function used as `command` must return the filepath.  

Some additional implementation considerations:

* In order to use `tar_combine()` with the output from `tar_map()`, you will need to save the results of `tar_map()` as an object. Thus, the branching declaration should look something like `mapped_output <- tar_map()` so that `mapped_output` can be used in your `tar_combine()` call.

* You can write your own combiner function or you can use built-in combiner functions for common types of combining (such as `bind_rows()`, `c()`, etc). If you write your own combiner function, it needs to be in a script sourced in the makefile using `source()`. The default combiner is `?vctrs::vec_c`, which is a a fancy version of `c()` that ensures the resulting vector keeps the common data type (e.g. factors remain factors).

* When you pass the output of `tar_map()` to `tar_combine()`, all branch output from `tar_map()` will be used by default. If you had multiple steps in your `tar_map()` (i.e. multiple calls to `tar_target()`), and you only want to combine results from one of those, you can add `unlist = FALSE` to your `tar_map()` call so that the `tar_map()` output remained in a nested list. This makes it possible to reference just the output from each `tar_target()` and use in `tar_combine()`. For example, if you had three steps in your `tap_map()` call and you wanted to combine only those branches from the third step, you could use `mapped_output[[3]]` as the input to `tar_combine()`.
