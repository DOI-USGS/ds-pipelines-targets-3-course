So far we've implemented *split* and *apply* operations; now it's time to explore *combine* operations in **targets** pipelines.

In this issue you'll add two *combiners* to serve different purposes - the first will combine all of the annual observation tallies into one giant table, and the second will summarize the set of state-specific timeseries plots generated by the task table. 

### Background

#### Approach

Given your current level of knowledge, if you were asked to add a target combining the tally outputs you would likely add a call to `tar_target` and use the branches as input to a `command` that aggregated the data. While this would certainly work, the number of inputs to a combiner should change if the number of tasks changes. If we hand-coded a combiner target with `tar_target` that accepted a set of inputs (e.g., `tar_target(combined_tallies, combine_tallies(tally_WI, tally_MI, [etc]))`), we'd need to manually edit the inputs to that function anytime we changed the `states` vector. That would be a pain and would make our pipeline susceptible to human error if we forgot or made a mistake in that editing. 

#### Implementation

The **targets** way to use combiners for static branching is to work with the `tar_combine()` function (recall that **combiners** are automatically applied to the output in dynamic branching). `tar_combine()` is set up in a similar way to `tar_target()`, where you supply the target name and a function to the target as the `command`. The difference is that the input to the `command` will be multiple targets passed in to the `...` argument. The output from a `tar_combine()` can be an R object or a file, but file targets need to have `format = "file"` passed in to `tar_combine()` and the function used as `command` must return the filepath.  

Some additional implementation considerations:

* In order to use `tar_combine()` with the output from `tar_map()`, you will need to save the output of `tar_map()` as an object. Thus, the branching declaration should look something like `mapped_output <- tar_map()` so that `mapped_output` can be used in your `tar_combine()` call.

* You can write your own combiner function or you can use built-in combiner functions for common types of combining (such as `bind_rows()`, `c()`, etc). If you write your own combiner function, it needs to be in a script sourced in the makefile using `source()`. The default combiner is `?vctrs::vec_c`, which is a a fancy version of `c()` that ensures the resulting vector keeps the common data type (e.g. factors remain factors).

* When you pass the output of `tar_map()` to `tar_combine()`, all branch output from `tar_map()` will be used by default. If you had multiple steps in your `tar_map()` (i.e. multiple calls to `tar_target()`), and you only want to combine results from one of those, you can add `unlist = FALSE` to your `tar_map()` call so that the `tar_map()` output remained in a nested list. This makes it possible to reference just the output from each `tar_target()` and use in `tar_combine()`. For example, if you had three steps in your `tap_map()` call and you wanted to combine only those branches from the third step that had a target name of `sum_resuts`, you could use `mapped_output[[3]]` or `mapped_output$sum_results` as the input to `tar_combine()`. 

* Within your `tar_combine()` function, pass the `...` to your `command` function by specifying `!!!.x` in its place. It feels strange, but has to do with how the function handles non-standard evaluation. You can see an example of using this syntax when you look at the default for `command` in thehelp file for `?tarchetypes::tar_combine()`.

* When specifying the `command` argument to `tar_combine()`, you need to include the argument, e.g. `command = my_function()`. Since `tar_combine()` has `...` as its second argument, anything else you pass in without the argument name will be considered part of `...`. It can result in some weird errors.

Don't worry if not all of this clicked yet. We are about to see it all in action!
