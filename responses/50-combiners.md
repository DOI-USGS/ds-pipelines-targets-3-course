So far we've implemented *split* and *apply* operations; now it's time to explore *combine* operations in **scipiper** pipelines.

In this issue you'll add two *combiners* to serve different purposes - the first will combine all of the annual observation tallies into one giant table, and the second will summarize the set of state-specific timeseries plots generated by the task table. We'll use the second combiner in a target within the main *remake.yml*, downstream of the whole task table, to illustrate how task tables can fit into the flow of a longer pipeline.

### Background

#### Approach

*Combiners* in **scipiper** are functions that accept a set of task-step targets as arguments and produce a single file or R object as output. We define their corresponding targets within the task remakefile (as opposed to within the main *remake.yml*) for several reasons:

1. Only the task remakefile actually knows the identities and locations of the task steps. This information is unavailable to the main pipeline, which you can confirm by running `remake::diagram(remake_file='remake.yml')` and searching in vain for targets such as `WI_tally`:

![remake::diagram](https://user-images.githubusercontent.com/12039957/83043496-f7785200-a010-11ea-8354-43e2d7ca2892.png)

2. For the same reasons that **purrr** and **dplyr** allow you to implement *split*, *apply*, and *combine* operations all in a single expression, it's conceptually tidier to think of those three operations as a bundle within **scipiper** pipelines, and therefore to code them all in the same place.

3. The number of inputs to a combiner should change if the number of tasks changes. If we hand-coded a combiner target with a `command` function that accepted a set of inputs (e.g., `command: combine_tallies(WI_tally, MI_tally, [etc])`), we'd need to manually edit the inputs to that function anytime we changed the `states` vector. That would be a pain and would make our pipeline susceptible to human error if we forgot or made a mistake in that editing. It's safer if we can automatically generate that list of inputs along with the rest of the task remakefile.

#### Implementation

The **scipiper** way to use combiners is to work with the `finalize_funs`, `final_targets`, `as_promises`, and `tickquote_combinee_objects` arguments to `create_task_makefile()`. Once you've set up these arguments properly, `create_task_makefile()` will write combiner targets into your task remakefile for you, autopopulating the arguments to match the final step of each task.

* The `finalize_funs` argument is a vector of one or more function names, each one of which will be called as the `command` to create a combiner target. Note that you don't get to specify anything else about your combiners here except their names. You can write your own combiner function or you can use the built-in `combine_to_ind()` combiner for a common type of combining (you'll see when we try it out). If you write your own combiner function, it should be defined within one of the `sources` or `packages` specified in `create_task_makefile()`.

* You don't get choices about the list of arguments that a combiner function will accept: If the output of your combiner will be a file, your combiner function must accept arguments that are a summary filename, the output from task 1, the output from task 2, and so on, in that order, and your combiner must write the output to the filename given by the summary filename argument. If the output of your combiner will be an R object, your combiner function should skip straight to the outputs from the tasks (and not accept an initial filename argument) and should return an R object. The declaration of the combiner function should therefore either be `function(out_file, ...)` or `function(...)` (where the name of the `outfile` argument is up to you).

* The `final_targets` argument is a vector of target names for your one or more combiner targets. This argument's length needs to exactly match that of `finalize_funs` and will be mapped 1:1 to those target functions. If a `finalize_fun` (combiner) will return a file, the corresponding `final_targets` value should be a filename. It the combiner will return an R object, the `final_targets` value should be a valid object target name.

* The utility of `as_promises=TRUE` will become clearer with an illustration shortly. For now you can use `as_promises=FALSE`.

* We've been working with `tickquote_combinee_objects=FALSE` largely because you don't have any combiners. Once you add them, you should pretty much always use `tickquote_combinee_objects=TRUE`. This argument helps `create_task_makefile` format the remakefile correctly across a range of possible *apply* and *combine* operations.
